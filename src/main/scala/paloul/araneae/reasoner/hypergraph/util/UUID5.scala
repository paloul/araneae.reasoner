package paloul.araneae.reasoner.hypergraph.util

/**
 * Companion object to UUID5. Provides the only means to create UUID5 instances.
 * UUID5 is a Level 5 implementation of UUID. The class instance is light wrapper
 * around java.util.UUID.
 *
 * Version (Level) 5 UUIDs are generated by hashing a namespace identifier and name.
 * The hash algorithm used is SHA-1. Generating a Version 5 UUID with the same namespace
 * identifier and name will always generate the same UUID.
 */
object UUID5 {
  import java.security.MessageDigest

  private final val ARANEAE_NAMESPACE: String = "6aa4b801-9dad-11d1-80b4-00c04fe330c1"
  private final val MESSAGEDIGEST = MessageDigest.getInstance("SHA-1")

  /**
   * Instantiate a new UUID5 from given arbitrary string. Underlying UUID5 is version Level 5.
   * Level 5 UUIDs generate the same uuid hex value given the same string name. Level 5 specs
   * define it as using the SHA-1 algorithm to generate the hash. Level 3 is very similar but
   * uses MD5 algorithm instead. If Level5 with SHA-1 proves to have too much unwanted performance
   * impact, then this utility class/object can be modded to use Level 3 UUID5 specs with MD5.
   *
   * @param name Any arbitrary string value that will be hashed to generate uuid
   * @return A UUID representing a hash of the given string name and araneae namespace
   */
  def apply(name: String): UUID = {
    generateType5UUID(ARANEAE_NAMESPACE, name)
  }

  /**
   * Generate UUID instance from a string representation of UUID
   * @param uuidString A string that specifies a UUID
   * @return UUID with the specified value defined by uuid string
   */
  def fromString(uuidString: String): UUID = {
    // Use static method to convert String UUID to java.util.UUID instance
    val uuid = java.util.UUID.fromString(uuidString)

    // Convert to our UUID5 wrapper
    new UUID5(uuid.getMostSignificantBits, uuid.getLeastSignificantBits)
  }

  /**
   * Take in a namespace and name to generate a Level 5 UUID5
   * @param namespace Any arbitrary string value that will be hashed to generate uuid
   * @param name Any arbitrary string value that will be hashed to generate uuid
   * @return UUID5
   */
  private def generateType5UUID(namespace: String, name: String): UUID = {
    val nameSpaceBytes = bytesFromUUID(namespace)
    val nameBytes = name.getBytes("UTF-8")
    val result = joinBytes(nameSpaceBytes, nameBytes)

    type5UUIDFromBytes(result)
  }

  /**
   * Takes an arbitrary byte array and modifies the version and variant bits
   * to represent a Level 5 UUID correctly
   * @param name Arbitrary string in bytes
   * @return
   */
  private def type5UUIDFromBytes(name: Array[Byte]): UUID = {
    import java.util

    val bytes = util.Arrays.copyOfRange(MESSAGEDIGEST.digest(name), 0, 16)
    bytes(6) &= 0x0f /* clear version        */
    bytes(6) |= 0x50 /* set to version 5     */
    bytes(8) &= 0x3f /* clear variant        */
    bytes(8) |= 0x80 /* set to IETF variant  */

    constructType5UUID(bytes)
  }

  /**
   * Takes a byte array representing a Level 5 UUID, isolates the Most and Least
   * Significant bits and uses them to create a Java Util UUID
   * @param data Byte Array of length 16 to turn into UUID
   * @return java.util.uuid
   */
  private def constructType5UUID(data: Array[Byte]): UUID = {
    var msb = 0
    var lsb = 0

    assert(data.length eq 16, "data must be 16 bytes in length")

    for (i <- 0 until 8) {
      msb = (msb << 8) | (data(i) & 0xff)
    }

    for (i <- 8 until 16) {
      lsb = (lsb << 8) | (data(i) & 0xff)
    }

    // Create a Java UUID given the Most Sig bits and Least Sig bits
    // from the generated byte array representing a Level 5 UUID
    new UUID5(msb, lsb)
  }

  /**
   * Convert the given hex string representation of uuid to an array of bytes
   * @param uuidHexString The uuid in string form
   * @return Byte array representing the given uuid
   */
  private def bytesFromUUID(uuidHexString: String) = {
    // Remove the dashes (-) from the given uuid string
    val normalizedUUIDHexString = uuidHexString.replace("-", "")

    // There are 4 dashes (-) in any uuid. Total 36 chars long.
    // Remove 4 dashes and you have 32 chars.
    assert(normalizedUUIDHexString.length == 32)

    val bytes = new Array[Byte](16)
    for (i <- 0 until 16) {
      val b = hexToByte(normalizedUUIDHexString.substring(i * 2, i * 2 + 2))
      bytes(i) = b
    }

    bytes
  }

  /**
   * Convert the given string that represents a single hex value to its byte representation
   * @param hexString The hex value in string form
   * @return Numeric value in bytes of the hex string
   */
  private def hexToByte(hexString: String): Byte = {
    val firstDigit = Character.digit(hexString.charAt(0), 16)
    val secondDigit = Character.digit(hexString.charAt(1), 16)

    ((firstDigit << 4) + secondDigit).toByte
  }

  /**
   * Combine two byte arrays into one
   * @param byteArray1 Byte Array One
   * @param byteArray2 Byte Array Two
   * @return New Array of Bytes joining the given byte arrays
   */
  private def joinBytes(byteArray1: Array[Byte], byteArray2: Array[Byte]): Array[Byte] = {
    val finalLength = byteArray1.length + byteArray2.length
    val result = new Array[Byte](finalLength)

    for (i <- byteArray1.indices) {
      result(i) = byteArray1(i)
    }
    for (i <- byteArray2.indices) {
      result(byteArray1.length + i) = byteArray2(i)
    }

    result
  }
}

/**
 * A wrapper around java.util.UUID. Can be instantiated only by its companion object.
 * Represents a Level 5 UUID.
 * Version-3 and version-5 UUIDs are generated by hashing a namespace identifier and name.
 * Version 3 uses MD5 as the hashing algorithm, and version 5 uses SHA-1
 *
 * @param mostSigBits The most significant bits of the UUID
 * @param leastSigBits The least significant bits of the UUID
 */
class UUID5 private (val mostSigBits: Long, val leastSigBits: Long) extends UUID {

  override val uuid: java.util.UUID = new java.util.UUID(mostSigBits, leastSigBits)

}
